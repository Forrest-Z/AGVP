//
// Created by shydh on 7/22/17.
//

#ifndef AGVP_MEASUREMENTMODEL_H
#define AGVP_MEASUREMENTMODEL_H

#include "conditionalpdf.h"
#include "sample.h"

namespace bfl_core
{
    #define NUMBER_OF_CONDITIONAL_ARGS 2

    /** Template class representing all possible (continu and discrete)
        Measurement Models
        @todo Check if there should be a "model" base class...
        @note Contrary to the system model, this template class has 2
        template arguments: this is because of the different nature of the
        2 conditional densities \f$ P ( Z | X ) \f$ and \f$ P ( X_k |
        X_{k-1} ) \f$
        If \f$ X_{k-1} \f$ is discrete, then \f$ X_{k} \f$ will also be
        discrete, but a discrete state doesn't automatically imply a
        discrete measurement (as is proven in ASR!)
    */
    template<typename MeasVar, typename StateVar>
    class MeasurementModel
    {
    protected:
        /// ConditionalPdf representing \f$ P(Z_k | X_{k}, U_{k}) \f$
        /* @bug Since, for now, the library only supports only conditional
           arguments of the same type, both X and U have to be of the same
           type (ie both continu or both discrete!).  I imagine there must
           be systems for which this approach is not general enough @see
           ConditionalPdf
        */
        ConditionalPdf<MeasVar,StateVar>* _MeasurementPdf;

        /// System with no sensor params??
        bool _systemWithoutSensorParams;

    public:
        /// Constructor
        /** @param Measurementpdf ConditionalPdf<MeasVar,StateVar> representing \f$ P(Z_k
        | X_{k} (, U_{k})) \f$
        @see MEASUREMENT_SIZE, STATE_SIZE, INPUT_SIZE, _MeasurementPdf
        */
        MeasurementModel(ConditionalPdf<MeasVar,StateVar>* Measurementpdf = NULL);
        /// Destructor
        virtual ~MeasurementModel();

        /// Get Measurement Size
        int MeasurementSizeGet() const;

        /// Number of Conditional Arguments
        bool SystemWithoutSensorParams() const;

        /// Get the MeasurementPDF
        ConditionalPdf<MeasVar,StateVar>* MeasurementPdfGet();

        /// Set the MeasurementPDF
        /** @param pdf a pointer to the measurement pdf
         */
        void MeasurementPdfSet(ConditionalPdf<MeasVar,StateVar> * pdf);

        /// Simulate the Measurement, given a certain state, and an input
        /** @param x current state of the system
        @param s sensor parameter
        @return Measurement generated by simulating the measurement model
        @param sampling_method the sampling method to be used while
        sampling from the Conditional Pdf describing the system (if not
        specified = DEFAULT)
        @param sampling_args Sometimes a sampling method can have some
        extra parameters (eg mcmc sampling)
        @note Maybe the return value would better be a Sample<StateVar> instead
        of a StateVar
        */
        MeasVar Simulate (const StateVar& x, const StateVar& s,
                          int sampling_method = DEFAULT, void * sampling_args = NULL);

        /// Simulate the system (no input system)
        /** @param x current state of the system
        @return State where we arrive by simulating the measurement model
        @note Maybe the return value would better be a Sample<StateVar> instead
        of a StateVar
        @param sampling_method the sampling method to be used while
        sampling from the Conditional Pdf describing the system (if not
        specified = DEFAULT)
        @param sampling_args Sometimes a sampling method can have some
        extra parameters (eg mcmc sampling)
        */
        MeasVar Simulate (const StateVar& x,
                          int sampling_method = DEFAULT, void * sampling_args = NULL);

        /// Get the probability of a certain measurement
        /** given a certain state and input
        @param z the measurement value
        @param x current state of the system
        @param s the sensor param value
        @return the "probability" of the measurement
        */
        double ProbabilityGet(const MeasVar& z, const StateVar& x, const StateVar& s );

        /// Get the probability of a certain measurement
        /** (measurement independent of input) gived a certain state and
        input
        @param z the measurement value
        @param x x current state of the system
        @return the "probability" of the measurement
        */
        double ProbabilityGet(const MeasVar& z, const StateVar& x );
    };

    // Constructor
    template<typename MeasVar, typename StateVar>
    MeasurementModel<MeasVar,
            StateVar>::MeasurementModel(ConditionalPdf<MeasVar,StateVar>* measurementpdf)
    {
        if (measurementpdf != NULL)
        {
            switch(measurementpdf->NumConditionalArgumentsGet())
            {
                case 1:
                {
                    _systemWithoutSensorParams = true;
                    _MeasurementPdf  = measurementpdf;
                    break;
                }
                case 2:
                {
                    _systemWithoutSensorParams = false;
                    _MeasurementPdf  = measurementpdf;
                    break;
                }
                default:{
                    return ;
                }
            }
        }
    }

// Destructor
    template<typename MeasVar, typename StateVar>
    MeasurementModel<MeasVar,StateVar>::~MeasurementModel()
    {
#ifdef __DESTRUCTOR__
        cout << "MeasurementModel::Destructor" << endl;
#endif // __DESTRUCTOR__
        /* KG: Probably a memory leak
           Who should clean this up? Sometimes the user will have created
           this Pdf, sometimes not (eg. by copy constructor).  If we allways
           delete it here.
           There has to be a cleaner way to implement this!
        */
        // delete _MeasurementPdf;
    }

// BUG: Should have copy constructor here?

// Get Measurement Size
    template<typename MeasVar, typename StateVar>
    int
    MeasurementModel<MeasVar,StateVar>::MeasurementSizeGet() const
    {
        return _MeasurementPdf->DimensionGet();
    }

    template<typename MeasVar, typename StateVar>
    bool
    MeasurementModel<MeasVar,StateVar>::SystemWithoutSensorParams() const
    {
        return _systemWithoutSensorParams;
    }

// Get MeasurementPdf
    template<typename MeasVar, typename StateVar>
    ConditionalPdf<MeasVar,StateVar>*
    MeasurementModel<MeasVar,StateVar>::MeasurementPdfGet()
    {
        return _MeasurementPdf;
    }

// Set MeasurementPdf
    template<typename MeasVar, typename StateVar>
    void
    MeasurementModel<MeasVar,
            StateVar>::MeasurementPdfSet(ConditionalPdf<MeasVar,StateVar> * pdf)
    {
        assert(pdf != NULL);
        switch(pdf->NumConditionalArgumentsGet())
        {
            case 1:
            {
                _systemWithoutSensorParams = true;
                _MeasurementPdf  = pdf;
                break;
            }
            case 2:
            {
                _systemWithoutSensorParams = false;
                _MeasurementPdf  = pdf;
                break;
            }
            default:
            {
                return;
            }
        }
    }

    template<typename MeasVar, typename StateVar>
    MeasVar
    MeasurementModel<MeasVar,StateVar>::Simulate (const StateVar& x,
                                                  const StateVar& s,
                                                  int sampling_method,
                                                  void * sampling_args)
    {
        //assert(_systemWithoutSensorParams == false);
        _MeasurementPdf->ConditionalArgumentSet(0,x);
        _MeasurementPdf->ConditionalArgumentSet(1,s);
        Sample<MeasVar> Simulated(MeasurementSizeGet());
        _MeasurementPdf->SampleFrom(Simulated, sampling_method,sampling_args);
        MeasVar result = Simulated.ValueGet();
        return result;
    }


    template<typename MeasVar, typename StateVar> MeasVar
    MeasurementModel<MeasVar,StateVar>::Simulate(const StateVar& x,
                                                 int sampling_method,
                                                 void * sampling_args)
    {
        //assert(_systemWithoutSensorParams == true);
        _MeasurementPdf->ConditionalArgumentSet(0,x);
        Sample<StateVar> Simulated(MeasurementSizeGet());
        _MeasurementPdf->SampleFrom(Simulated, sampling_method,sampling_args);
        MeasVar result = Simulated.ValueGet();
        return result;
    }

    template <typename MeasVar, typename StateVar>
    double
    MeasurementModel<MeasVar,StateVar>::ProbabilityGet (const MeasVar& z,
                                                        const StateVar& x,
                                                        const StateVar& s)
    {
        //assert(_systemWithoutSensorParams == false);
        _MeasurementPdf->ConditionalArgumentSet(0,x);
        _MeasurementPdf->ConditionalArgumentSet(1,s);
        return _MeasurementPdf->ProbabilityGet(z);
    }

    template <typename MeasVar, typename StateVar>
    double
    MeasurementModel<MeasVar,StateVar>::ProbabilityGet (const MeasVar& z,
                                                        const StateVar& x)
    {
        //assert(_systemWithoutSensorParams == true);
        _MeasurementPdf->ConditionalArgumentSet(0,x);
        return _MeasurementPdf->ProbabilityGet(z);
    }

}
#endif //AGVP_MEASUREMENTMODEL_H
